<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å•è¯ç§˜å¢ƒæ¢é™© - éŸ³æ•ˆä¼˜åŒ–ç‰ˆ</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            color: #fff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            overflow-x: hidden;
        }
        
        .container {
            width: 100%;
            max-width: 1200px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            width: 100%;
        }
        
        h1 {
            font-size: 3.2rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            background: linear-gradient(90deg, #ff9a9e, #fad0c4, #fad0c4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            letter-spacing: 2px;
        }
        
        .subtitle {
            font-size: 1.3rem;
            opacity: 0.9;
            margin-bottom: 20px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }
        
        .game-container {
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            width: 100%;
            max-width: 1000px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.1);
        }
        
        /* è§’è‰²é€‰æ‹©ç•Œé¢ */
        .character-selection {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }
        
        .selection-title {
            font-size: 2rem;
            margin-bottom: 25px;
            color: #ffcc00;
            text-shadow: 0 0 10px rgba(255, 204, 0, 0.5);
        }
        
        .character-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 25px;
            width: 100%;
            margin-bottom: 30px;
        }
        
        .character-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 25px 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border: 2px solid transparent;
        }
        
        .character-card:hover {
            transform: translateY(-5px);
            background: rgba(255, 255, 255, 0.2);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            border-color: #ffcc00;
        }
        
        .character-card.selected {
            border-color: #ffcc00;
            background: rgba(255, 204, 0, 0.1);
            box-shadow: 0 0 20px rgba(255, 204, 0, 0.5);
        }
        
        .character-icon {
            font-size: 4rem;
            margin-bottom: 15px;
        }
        
        .character-name {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 10px;
        }
        
        .character-desc {
            font-size: 1rem;
            opacity: 0.8;
            margin-bottom: 15px;
        }
        
        .character-skill {
            font-size: 0.9rem;
            color: #ffcc00;
            font-weight: 600;
        }
        
        /* éš¾åº¦é€‰æ‹© */
        .difficulty-selector {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            justify-content: center;
        }
        
        .difficulty-btn {
            padding: 10px 25px;
            border-radius: 20px;
            background: rgba(255, 255, 255, 0.15);
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }
        
        .difficulty-btn.active {
            background: rgba(255, 204, 0, 0.3);
            box-shadow: 0 0 10px rgba(255, 204, 0, 0.5);
        }
        
        /* æ¸¸æˆç•Œé¢ */
        .game-screen {
            display: none;
            flex-direction: column;
            align-items: center;
        }
        
        .game-header {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-bottom: 25px;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .player-stats {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .stat {
            font-size: 1.1rem;
            font-weight: 600;
            background: rgba(255, 255, 255, 0.2);
            padding: 10px 20px;
            border-radius: 50px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .map-container {
            width: 100%;
            height: 200px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            margin-bottom: 30px;
            position: relative;
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }
        
        .map-path {
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            height: 10px;
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-50%);
        }
        
        .map-node {
            position: absolute;
            top: 50%;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #4a4a4a;
            transform: translate(-50%, -50%);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }
        
        .map-node.active {
            background: #ffcc00;
            box-shadow: 0 0 15px rgba(255, 204, 0, 0.7);
        }
        
        .map-node.completed {
            background: #4CAF50;
        }
        
        .map-node i {
            font-size: 1.2rem;
        }
        
        .game-content {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .puzzle-title {
            font-size: 1.8rem;
            margin-bottom: 20px;
            color: #ffcc00;
            text-align: center;
        }
        
        .word-display {
            font-size: 3rem;
            font-weight: 700;
            margin: 20px 0 40px;
            text-align: center;
            text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.3);
            color: #ffcc00;
        }
        
        .puzzle-container {
            width: 100%;
            margin-bottom: 30px;
        }
        
        .timer-container {
            width: 100%;
            height: 10px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            margin-bottom: 30px;
            overflow: hidden;
        }
        
        .timer-bar {
            height: 100%;
            background: linear-gradient(90deg, #ff9a9e 0%, #fad0c4 100%);
            width: 100%;
            transition: width 0.1s linear;
        }
        
        .game-controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        button {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            padding: 12px 25px;
            border-radius: 50px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button.primary {
            background: linear-gradient(90deg, #ff9a9e, #fad0c4);
            color: #333;
        }
        
        /* é“å…·æ  */
        .inventory {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .item {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 10px 15px;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .item:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .item-count {
            font-weight: 700;
            color: #ffcc00;
        }
        
        /* ç»“æœç•Œé¢ */
        .result-screen {
            display: none;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }
        
        .result-title {
            font-size: 2.5rem;
            margin-bottom: 20px;
            color: #ffcc00;
        }
        
        .final-score {
            font-size: 5rem;
            font-weight: 700;
            margin: 20px 0;
            color: #ffeb3b;
            text-shadow: 0 0 10px rgba(255, 235, 59, 0.5);
        }
        
        .result-message {
            font-size: 1.3rem;
            margin-bottom: 30px;
            max-width: 600px;
        }
        
        .rewards {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .reward-item {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            min-width: 120px;
        }
        
        .reward-icon {
            font-size: 2.5rem;
            color: #ffcc00;
        }
        
        /* éŸ³ä¹æ§åˆ¶ */
        .music-control {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 100;
            transition: all 0.3s;
        }
        
        .music-control:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }
        
        .music-icon {
            font-size: 1.5rem;
        }
        
        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 768px) {
            .character-grid {
                grid-template-columns: 1fr;
            }
            
            .word-display {
                font-size: 2.5rem;
            }
            
            .game-header {
                justify-content: center;
            }
        }
        
        @media (max-width: 480px) {
            .word-display {
                font-size: 2rem;
            }
            
            .difficulty-selector {
                flex-direction: column;
                align-items: center;
            }
        }
        
        /* åŠ¨ç”»æ•ˆæœ */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .pulse {
            animation: pulse 2s infinite;
        }
        
        /* äº‹ä»¶å¼¹çª— */
        .event-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border-radius: 15px;
            padding: 30px;
            z-index: 1000;
            max-width: 500px;
            width: 90%;
            text-align: center;
            border: 2px solid #ffcc00;
            box-shadow: 0 0 30px rgba(255, 204, 0, 0.5);
            display: none;
        }
        
        .event-title {
            font-size: 1.8rem;
            margin-bottom: 15px;
            color: #ffcc00;
        }
        
        .event-desc {
            font-size: 1.2rem;
            margin-bottom: 25px;
        }
        
        .event-options {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .event-option {
            padding: 10px 20px;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.1);
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .event-option:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        /* è°œé¢˜ç±»å‹ç‰¹å®šæ ·å¼ */
        .matching-puzzle {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
        }
        
        .word-item, .meaning-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px 25px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .word-item:hover, .meaning-item:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .word-item.selected, .meaning-item.selected {
            background: rgba(255, 204, 0, 0.3);
        }
        
        .fill-blank-puzzle {
            font-size: 2rem;
            margin: 20px 0;
            text-align: center;
        }
        
        .blank-input {
            width: 60px;
            font-size: 1.5rem;
            text-align: center;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 5px;
            color: white;
            padding: 5px;
        }
        
        .sentence-puzzle {
            font-size: 1.5rem;
            margin: 20px 0;
            text-align: center;
            line-height: 1.6;
        }
        
        .sentence-input {
            width: 200px;
            font-size: 1.2rem;
            text-align: center;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 5px;
            color: white;
            padding: 8px;
            margin: 0 10px;
        }
        
        .synonym-puzzle {
            font-size: 1.5rem;
            margin: 20px 0;
            text-align: center;
        }
        
        .synonym-input {
            width: 200px;
            font-size: 1.2rem;
            text-align: center;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 5px;
            color: white;
            padding: 8px;
            margin: 0 10px;
        }
        
        .antonym-puzzle {
            font-size: 1.5rem;
            margin: 20px 0;
            text-align: center;
        }
        
        .antonym-input {
            width: 200px;
            font-size: 1.2rem;
            text-align: center;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 5px;
            color: white;
            padding: 8px;
            margin: 0 10px;
        }
        
        /* æç¤ºç³»ç»Ÿ */
        .hint-container {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .hint-title {
            font-size: 1.2rem;
            color: #ffcc00;
            margin-bottom: 10px;
        }
        
        .hint-content {
            font-size: 1.1rem;
        }
        
        /* å•è¯å¡ç‰‡ */
        .word-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin: 15px 0;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .word-card-title {
            font-size: 1.5rem;
            color: #ffcc00;
            margin-bottom: 10px;
        }
        
        .word-card-content {
            font-size: 1.2rem;
            line-height: 1.6;
        }
        
        /* è¿·ä½ æ¸¸æˆ */
        .minigame-container {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin: 15px 0;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .minigame-title {
            font-size: 1.5rem;
            color: #ffcc00;
            margin-bottom: 15px;
        }
        
        .minigame-content {
            font-size: 1.2rem;
            line-height: 1.6;
        }
        
        .minigame-input {
            width: 200px;
            font-size: 1.2rem;
            text-align: center;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 5px;
            color: white;
            padding: 8px;
            margin: 10px;
        }
        
        /* éŸ³æ•ˆæ§åˆ¶ */
        .sound-control {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 100;
            transition: all 0.3s;
        }
        
        .sound-control:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }
        
        .sound-icon {
            font-size: 1.5rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>å•è¯ç§˜å¢ƒæ¢é™©</h1>
            <p class="subtitle">é«˜ä¸­å•è¯å¼ºåŒ–è®­ç»ƒ - å¼€å¯ä½ çš„è¯æ±‡å†’é™©ä¹‹æ—…ï¼</p>
        </header>
        
        <!-- éŸ³ä¹æ§åˆ¶ -->
        <div class="music-control" id="musicControl">
            <div class="music-icon">ğŸµ</div>
        </div>
        
        <!-- éŸ³æ•ˆæ§åˆ¶ -->
        <div class="sound-control" id="soundControl">
            <div class="sound-icon">ğŸ”Š</div>
        </div>
        
        <div class="game-container">
            <!-- è§’è‰²é€‰æ‹©ç•Œé¢ -->
            <div class="character-selection" id="characterSelection">
                <h2 class="selection-title">é€‰æ‹©ä½ çš„æ¢é™©èº«ä»½</h2>
                
                <div class="character-grid">
                    <div class="character-card" data-character="hunter">
                        <div class="character-icon">ğŸ¹</div>
                        <div class="character-name">çŒäºº</div>
                        <div class="character-desc">æ•é”çš„è§‚å¯Ÿè€…ï¼Œæ“…é•¿å¿«é€Ÿååº”</div>
                        <div class="character-skill">æŠ€èƒ½ï¼šé™æ—¶é¢˜é¢å¤–+5ç§’</div>
                    </div>
                    <div class="character-card" data-character="scholar">
                        <div class="character-icon">ğŸ“š</div>
                        <div class="character-name">å­¦è€…</div>
                        <div class="character-desc">çŸ¥è¯†æ¸Šåšï¼Œå–„äºæ€è€ƒåˆ†æ</div>
                        <div class="character-skill">æŠ€èƒ½ï¼šåˆå§‹å¤š2å¼ æç¤ºåˆ¸</div>
                    </div>
                    <div class="character-card" data-character="craftsman">
                        <div class="character-icon">âš’ï¸</div>
                        <div class="character-name">å·¥åŒ </div>
                        <div class="character-desc">å·§æ‰‹åŒ å¿ƒï¼Œå–„äºä¿®å¤ç‰©å“</div>
                        <div class="character-skill">æŠ€èƒ½ï¼šå¤æ´»å¡50%æ¦‚ç‡å›æ”¶</div>
                    </div>
                </div>
                
                <!-- éš¾åº¦é€‰æ‹© -->
                <h2 class="selection-title" style="margin-top: 30px;">é€‰æ‹©æ¢é™©éš¾åº¦</h2>
                <div class="difficulty-selector">
                    <div class="difficulty-btn active" data-difficulty="easy">åŸºç¡€è¯æ±‡</div>
                    <div class="difficulty-btn" data-difficulty="medium">æ ¸å¿ƒè¯æ±‡</div>
                    <div class="difficulty-btn" data-difficulty="hard">é«˜çº§è¯æ±‡</div>
                </div>
                
                <button id="startAdventure" class="primary">
                    <i class="fas fa-play"></i> å¼€å§‹æ¢é™©
                </button>
            </div>
            
            <!-- æ¸¸æˆç•Œé¢ -->
            <div class="game-screen" id="gameScreen">
                <div class="game-header">
                    <div class="player-stats">
                        <div class="stat">
                            <i class="fas fa-heart" style="color: #ff5252;"></i>
                            <span id="healthValue">5</span>/5
                        </div>
                        <div class="stat">
                            <i class="fas fa-star" style="color: #ffcc00;"></i>
                            <span id="scoreValue">0</span> åˆ†
                        </div>
                        <div class="stat">
                            <i class="fas fa-map-marker-alt" style="color: #4CAF50;"></i>
                            <span id="locationValue">æ£®æ—å…¥å£</span>
                        </div>
                    </div>
                    <div class="player-stats">
                        <div class="stat">
                            <i class="fas fa-user" style="color: #64b5f6;"></i>
                            <span id="characterName">çŒäºº</span>
                        </div>
                        <div class="stat">
                            <i class="fas fa-shield-alt" style="color: #ba68c8;"></i>
                            <span id="difficultyName">åŸºç¡€</span>
                        </div>
                    </div>
                </div>
                
                <div class="map-container">
                    <div class="map-path"></div>
                    <div class="map-node completed" style="left: 10%;" data-node="1">
                        <i class="fas fa-tree"></i>
                    </div>
                    <div class="map-node active" style="left: 30%;" data-node="2">
                        <i class="fas fa-water"></i>
                    </div>
                    <div class="map-node" style="left: 50%;" data-node="3">
                        <i class="fas fa-mountain"></i>
                    </div>
                    <div class="map-node" style="left: 70%;" data-node="4">
                        <i class="fas fa-dungeon"></i>
                    </div>
                    <div class="map-node" style="left: 90%;" data-node="5">
                        <i class="fas fa-gem"></i>
                    </div>
                </div>
                
                <div class="game-content">
                    <h2 class="puzzle-title" id="puzzleTitle">å•è¯åŒ¹é…æŒ‘æˆ˜</h2>
                    
                    <!-- è°œé¢˜å®¹å™¨ - åŠ¨æ€åŠ è½½ä¸åŒè°œé¢˜ -->
                    <div class="puzzle-container" id="puzzleContainer">
                        <!-- è°œé¢˜å†…å®¹å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
                    </div>
                    
                    <div class="timer-container">
                        <div class="timer-bar" id="timerBar"></div>
                    </div>
                    
                    <div class="game-controls">
                        <button id="useHint">
                            <i class="fas fa-lightbulb"></i> ä½¿ç”¨æç¤º
                        </button>
                        <button id="nextPuzzle" disabled>
                            <i class="fas fa-arrow-right"></i> ç»§ç»­æ¢é™©
                        </button>
                        <button id="quitAdventure">
                            <i class="fas fa-door-open"></i> é€€å‡ºæ¢é™©
                        </button>
                    </div>
                    
                    <div class="inventory">
                        <div class="item" id="hintItem">
                            <i class="fas fa-lightbulb" style="color: #ffcc00;"></i>
                            æç¤ºåˆ¸ <span class="item-count" id="hintCount">3</span>
                        </div>
                        <div class="item" id="reviveItem">
                            <i class="fas fa-redo" style="color: #4CAF50;"></i>
                            å¤æ´»å¡ <span class="item-count" id="reviveCount">1</span>
                        </div>
                        <div class="item" id="detectorItem">
                            <i class="fas fa-search" style="color: #64b5f6;"></i>
                            æ¢æµ‹ä»ª <span class="item-count" id="detectorCount">1</span>
                        </div>
                        <div class="item" id="swapItem">
                            <i class="fas fa-exchange-alt" style="color: #ba68c8;"></i>
                            äº¤æ¢å¡ <span class="item-count" id="swapCount">1</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- ç»“æœç•Œé¢ -->
            <div class="result-screen" id="resultScreen">
                <h2 class="result-title">æ¢é™©å®Œæˆ!</h2>
                <div class="final-score" id="finalScore">0</div>
                <p class="result-message" id="resultMessage">ä½ æˆåŠŸå®Œæˆäº†å•è¯ç§˜å¢ƒæ¢é™©!</p>
                
                <div class="rewards">
                    <div class="reward-item">
                        <div class="reward-icon">ğŸ†</div>
                        <div>æ¢é™©å¥–ç« </div>
                    </div>
                    <div class="reward-item">
                        <div class="reward-icon">ğŸ“š</div>
                        <div>è¯æ±‡æ‰‹å†Œ</div>
                    </div>
                    <div class="reward-item">
                        <div class="reward-icon">ğŸ”‘</div>
                        <div>éšè—åŒºåŸŸé’¥åŒ™</div>
                    </div>
                </div>
                
                <div class="game-controls">
                    <button id="playAgainBtn" class="primary">
                        <i class="fas fa-redo"></i> å†æ¬¡æ¢é™©
                    </button>
                    <button id="changeCharacterBtn">
                        <i class="fas fa-user"></i> æ›´æ¢èº«ä»½
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- äº‹ä»¶å¼¹çª— -->
    <div class="event-popup" id="eventPopup">
        <h2 class="event-title" id="eventTitle">å‘ç°éšè—å®ç®±!</h2>
        <p class="event-desc" id="eventDesc">ä½ å‘ç°äº†ä¸€ä¸ªå¤è€çš„å®ç®±ï¼Œé‡Œé¢ä¼¼ä¹æœ‰çè´µçš„é“å…·ã€‚æ˜¯å¦æ‰“å¼€ï¼Ÿ</p>
        <div class="event-options">
            <div class="event-option" id="eventOption1">æ‰“å¼€å®ç®±</div>
            <div class="event-option" id="eventOption2">è°¨æ…ç¦»å¼€</div>
        </div>
    </div>

    <!-- éŸ³é¢‘å…ƒç´  -->
    <audio id="backgroundMusic" loop>
        <source src="https://assets.mixkit.co/music/preview/mixkit-tech-house-vibes-130.mp3" type="audio/mpeg">
    </audio>
    
    <!-- éŸ³æ•ˆå…ƒç´  -->
    <audio id="correctSound" preload="auto">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-correct-answer-tone-2870.mp3" type="audio/mpeg">
    </audio>
    
    <audio id="wrongSound" preload="auto">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-wrong-answer-fail-notification-946.mp3" type="audio/mpeg">
    </audio>
    
    <audio id="clickSound" preload="auto">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-select-click-1109.mp3" type="audio/mpeg">
    </audio>
    
    <audio id="hintSound" preload="auto">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-magic-sparkle-3026.mp3" type="audio/mpeg">
    </audio>
    
    <audio id="levelUpSound" preload="auto">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-winning-chimes-2015.mp3" type="audio/mpeg">
    </audio>

    <script>
        // æ¸¸æˆæ•°æ® - é«˜ä¸­è‹±è¯­å•è¯ï¼ˆä¼˜åŒ–ç‰ˆï¼‰
        const gameData = {
            easy: {
                words: ["abandon", "ability", "abroad", "absence", "absolute", "absorb", "abstract", "academic", "accent", "accept"],
                meanings: ["æ”¾å¼ƒ", "èƒ½åŠ›", "åœ¨å›½å¤–", "ç¼ºå¸­", "ç»å¯¹çš„", "å¸æ”¶", "æŠ½è±¡çš„", "å­¦æœ¯çš„", "å£éŸ³", "æ¥å—"],
                sentences: [
                    "He decided to ____ his studies and travel the world.",
                    "She has the ____ to solve complex problems quickly.",
                    "Many students choose to study ____ for a year.",
                    "His ____ from the meeting was noticed by everyone.",
                    "We have ____ confidence in your abilities.",
                    "Plants ____ water through their roots.",
                    "The concept was too ____ for the students to understand.",
                    "She pursued an ____ career in research.",
                    "He spoke with a strong British ____.",
                    "I gladly ____ your generous offer."
                ],
                fillBlanks: [
                    "A_A_D_N", "A_I_I_Y", "A_R_A_", "A_S_N_E", "A_S_L_T_",
                    "A_S_R_", "A_T_A_T", "A_A_E_I_", "A_C_N_", "A_C_E_T"
                ],
                synonyms: [
                    "desert", "capability", "overseas", "nonattendance", "complete",
                    "soak up", "theoretical", "scholarly", "pronunciation", "receive"
                ],
                antonyms: [
                    "keep", "inability", "domestic", "presence", "relative",
                    "release", "concrete", "practical", "silence", "refuse"
                ],
                hints: [
                    "æ„æ€æ˜¯æ”¾å¼ƒæˆ–ç¦»å¼€ï¼Œå¸¸ç”¨äºæ”¾å¼ƒè®¡åˆ’æˆ–è´£ä»»",
                    "æŒ‡åšæŸäº‹çš„èƒ½åŠ›æˆ–æŠ€èƒ½ï¼Œä¸capabilityåŒä¹‰",
                    "è¡¨ç¤ºåœ¨å›½å¤–æˆ–æµ·å¤–ï¼Œä¸overseasæ„æ€ç›¸è¿‘",
                    "æŒ‡ä¸åœ¨åœºæˆ–ç¼ºå¸­ï¼Œåä¹‰è¯æ˜¯presence",
                    "è¡¨ç¤ºå®Œå…¨æˆ–ç»å¯¹çš„ï¼Œæ²¡æœ‰ä»»ä½•é™åˆ¶æˆ–æ¡ä»¶",
                    "æ„æ€æ˜¯å¸æ”¶æˆ–å¸å…¥ï¼Œå¦‚æ¤ç‰©å¸æ”¶æ°´åˆ†",
                    "è¡¨ç¤ºæŠ½è±¡æˆ–ç†è®ºæ€§çš„ï¼Œåä¹‰è¯æ˜¯concrete",
                    "ä¸å­¦æœ¯æˆ–æ•™è‚²ç›¸å…³ï¼ŒæŒ‡å­¦æ ¡æˆ–ç ”ç©¶é¢†åŸŸ",
                    "æŒ‡è¯´è¯çš„å£éŸ³æˆ–è¯­è°ƒï¼Œä¸åŒåœ°åŒºæœ‰ä¸åŒçš„å£éŸ³",
                    "æ„æ€æ˜¯æ¥å—æˆ–åŒæ„ï¼Œåä¹‰è¯æ˜¯refuse"
                ]
            },
            medium: {
                words: ["accommodate", "accompany", "accomplish", "account", "accumulate", "accurate", "accuse", "achieve", "acknowledge", "acquire"],
                meanings: ["å®¹çº³", "é™ªä¼´", "å®Œæˆ", "è´¦æˆ·", "ç§¯ç´¯", "å‡†ç¡®çš„", "æŒ‡è´£", "å®ç°", "æ‰¿è®¤", "è·å¾—"],
                sentences: [
                    "The hotel can ____ up to 500 guests.",
                    "Will you ____ me to the party?",
                    "She managed to ____ all her goals for the year.",
                    "Please give me an ____ of what happened.",
                    "Dust tends to ____ in unused rooms.",
                    "Make sure your measurements are ____.",
                    "They ____ him of stealing the documents.",
                    "With hard work, you can ____ anything.",
                    "I must ____ that you were right all along.",
                    "She hopes to ____ new skills during the internship."
                ],
                fillBlanks: [
                    "A_C_M_O_A_E", "A_C_M_A_Y", "A_C_M_L_S_", "A_C_U_T", "A_C_M_L_T_",
                    "A_C_R_T_", "A_C_S_", "A_H_E_E", "A_K_O_L_D_E", "A_U_R_"
                ],
                synonyms: [
                    "house", "escort", "achieve", "report", "collect",
                    "precise", "blame", "attain", "admit", "obtain"
                ],
                antonyms: [
                    "evict", "leave", "fail", "conceal", "disperse",
                    "inaccurate", "defend", "lose", "deny", "lose"
                ],
                hints: [
                    "æ„æ€æ˜¯å®¹çº³æˆ–æä¾›ä½å®¿ï¼Œé…’åº—å¯ä»¥å®¹çº³å®¢äºº",
                    "è¡¨ç¤ºé™ªä¼´æˆ–é™ªåŒï¼Œä¸escortæ„æ€ç›¸è¿‘",
                    "æŒ‡å®Œæˆæˆ–å®ç°ç›®æ ‡ï¼Œä¸achieveåŒä¹‰",
                    "æ„æ€æ˜¯è´¦æˆ·æˆ–æè¿°ï¼Œä¹Ÿå¯ä»¥æŒ‡é“¶è¡Œè´¦æˆ·",
                    "è¡¨ç¤ºç§¯ç´¯æˆ–èšé›†ï¼Œå¦‚ç°å°˜åœ¨é—²ç½®æˆ¿é—´ç§¯ç´¯",
                    "æŒ‡å‡†ç¡®æˆ–ç²¾ç¡®çš„ï¼Œåä¹‰è¯æ˜¯inaccurate",
                    "æ„æ€æ˜¯æŒ‡è´£æˆ–æ§å‘Šï¼Œå¸¸ç”¨äºæ³•å¾‹è¯­å¢ƒ",
                    "è¡¨ç¤ºå®ç°æˆ–è¾¾æˆï¼Œé€šè¿‡åŠªåŠ›å¯ä»¥å®ç°ç›®æ ‡",
                    "æŒ‡æ‰¿è®¤æˆ–è®¤å¯ï¼Œæ‰¿è®¤æŸäº‹çš„çœŸå®æ€§",
                    "æ„æ€æ˜¯è·å¾—æˆ–å–å¾—ï¼Œé€šè¿‡å­¦ä¹ è·å¾—æ–°æŠ€èƒ½"
                ]
            },
            hard: {
                words: ["benevolent", "bilateral", "biography", "bizarre", "blatant", "boundary", "boycott", "brevity", "brilliant", "bureaucracy"],
                meanings: ["ä»æ…ˆçš„", "åŒè¾¹çš„", "ä¼ è®°", "å¥‡æ€ªçš„", "å…¬ç„¶çš„", "è¾¹ç•Œ", "æŠµåˆ¶", "ç®€æ´", "æ°å‡ºçš„", "å®˜åƒšåˆ¶åº¦"],
                sentences: [
                    "The ____ old man donated most of his wealth to charity.",
                    "The two countries signed a ____ trade agreement.",
                    "I'm reading a ____ of Albert Einstein.",
                    "The artist's work is known for its ____ imagery.",
                    "It was a ____ violation of the rules.",
                    "The river forms the ____ between the two countries.",
                    "They decided to ____ products from that company.",
                    "The ____ of his speech made it very effective.",
                    "She gave a ____ performance in the play.",
                    "Dealing with ____ can be frustrating and time-consuming."
                ],
                fillBlanks: [
                    "B_N_V_L_N_", "B_L_T_R_L", "B_O_R_P_Y", "B_Z_R_E", "B_A_A_T",
                    "B_U_D_R_", "B_Y_O_T", "B_E_I_Y", "B_I_L_A_T", "B_R_A_C_A_Y"
                ],
                synonyms: [
                    "kind", "mutual", "life story", "strange", "obvious",
                    "border", "embargo", "conciseness", "excellent", "administration"
                ],
                antonyms: [
                    "malevolent", "unilateral", "fiction", "normal", "subtle",
                    "center", "support", "verbosity", "dull", "simplicity"
                ],
                hints: [
                    "æ„æ€æ˜¯ä»æ…ˆæˆ–å–„è‰¯çš„ï¼Œåä¹‰è¯æ˜¯malevolent",
                    "è¡¨ç¤ºåŒè¾¹æˆ–åŒæ–¹çš„ï¼Œæ¶‰åŠä¸¤ä¸ªå›½å®¶æˆ–å›¢ä½“",
                    "æŒ‡ä¼ è®°æˆ–ä¸ªäººç”Ÿå¹³ï¼Œè®°å½•æŸäººçš„ä¸€ç”Ÿ",
                    "æ„æ€æ˜¯å¥‡æ€ªæˆ–æ€ªå¼‚çš„ï¼Œä¸åŒå¯»å¸¸çš„",
                    "è¡¨ç¤ºå…¬ç„¶æˆ–æ˜æ˜¾çš„ï¼Œæ¯«ä¸æ©é¥°çš„",
                    "æŒ‡è¾¹ç•Œæˆ–ç•Œé™ï¼Œå¦‚æ²³æµå½¢æˆçš„è¾¹ç•Œ",
                    "æ„æ€æ˜¯æŠµåˆ¶æˆ–æ‹’ç»ï¼Œæ‹’ç»è´­ä¹°æˆ–ä½¿ç”¨",
                    "è¡¨ç¤ºç®€æ´æˆ–ç®€çŸ­ï¼Œåä¹‰è¯æ˜¯verbosity",
                    "æŒ‡æ°å‡ºæˆ–å‡ºè‰²çš„ï¼Œéå¸¸ä¼˜ç§€çš„",
                    "æ„æ€æ˜¯å®˜åƒšåˆ¶åº¦æˆ–è¡Œæ”¿ä½“ç³»ï¼Œå¤æ‚çš„è¡Œæ”¿ç®¡ç†"
                ]
            }
        };

        // æ¸¸æˆçŠ¶æ€
        let gameState = {
            currentCharacter: null,
            currentDifficulty: 'easy',
            currentNode: 2,
            currentWordIndex: 0,
            currentPuzzleType: 0, // 0: é‡Šä¹‰é…å¯¹, 1: å­—æ¯å¡«ç©º, 2: ä¾‹å¥çŒœè¯, 3: åŒä¹‰è¯, 4: åä¹‰è¯, 5: å•è¯å¡ç‰‡
            score: 0,
            health: 5,
            timer: null,
            timeLeft: 0,
            totalTime: 25, // å»¶é•¿ç­”é¢˜æ—¶é—´
            musicPlaying: false,
            soundEnabled: true,
            hints: 3,
            revives: 1,
            detectors: 1,
            swaps: 1,
            locations: ["æ£®æ—å…¥å£", "çŒæœ¨ä¸›", "å°æºªè¾¹", "å¤æ ‘æ´", "åŸå ¡å¤§é—¨", "ç§˜å¢ƒç»ˆç‚¹"],
            puzzleTypes: ["é‡Šä¹‰é…å¯¹", "å­—æ¯å¡«ç©º", "ä¾‹å¥çŒœè¯", "åŒä¹‰è¯æŒ‘æˆ˜", "åä¹‰è¯æŒ‘æˆ˜", "å•è¯å¡ç‰‡"],
            isProcessing: false // é˜²æ­¢é‡å¤ç‚¹å‡»
        };

        // DOMå…ƒç´ 
        const characterSelection = document.getElementById('characterSelection');
        const gameScreen = document.getElementById('gameScreen');
        const resultScreen = document.getElementById('resultScreen');
        const startAdventureBtn = document.getElementById('startAdventure');
        const nextPuzzleBtn = document.getElementById('nextPuzzle');
        const quitAdventureBtn = document.getElementById('quitAdventure');
        const useHintBtn = document.getElementById('useHint');
        const playAgainBtn = document.getElementById('playAgainBtn');
        const changeCharacterBtn = document.getElementById('changeCharacterBtn');
        const healthValue = document.getElementById('healthValue');
        const scoreValue = document.getElementById('scoreValue');
        const locationValue = document.getElementById('locationValue');
        const characterName = document.getElementById('characterName');
        const difficultyName = document.getElementById('difficultyName');
        const puzzleTitle = document.getElementById('puzzleTitle');
        const puzzleContainer = document.getElementById('puzzleContainer');
        const timerBar = document.getElementById('timerBar');
        const finalScore = document.getElementById('finalScore');
        const resultMessage = document.getElementById('resultMessage');
        const musicControl = document.getElementById('musicControl');
        const soundControl = document.getElementById('soundControl');
        const backgroundMusic = document.getElementById('backgroundMusic');
        const correctSound = document.getElementById('correctSound');
        const wrongSound = document.getElementById('wrongSound');
        const clickSound = document.getElementById('clickSound');
        const hintSound = document.getElementById('hintSound');
        const levelUpSound = document.getElementById('levelUpSound');
        const difficultyBtns = document.querySelectorAll('.difficulty-btn');
        const characterCards = document.querySelectorAll('.character-card');
        const hintCount = document.getElementById('hintCount');
        const reviveCount = document.getElementById('reviveCount');
        const detectorCount = document.getElementById('detectorCount');
        const swapCount = document.getElementById('swapCount');
        const eventPopup = document.getElementById('eventPopup');
        const eventTitle = document.getElementById('eventTitle');
        const eventDesc = document.getElementById('eventDesc');
        const eventOption1 = document.getElementById('eventOption1');
        const eventOption2 = document.getElementById('eventOption2');

        // æ’­æ”¾éŸ³æ•ˆå‡½æ•°
        function playSound(sound) {
            if (gameState.soundEnabled) {
                sound.currentTime = 0;
                sound.play().catch(e => console.log("éŸ³æ•ˆæ’­æ”¾å¤±è´¥:", e));
            }
        }

        // è§’è‰²å¡ç‰‡ç‚¹å‡»äº‹ä»¶
        characterCards.forEach(card => {
            card.addEventListener('click', () => {
                playSound(clickSound);
                
                // ç§»é™¤ä¹‹å‰é€‰ä¸­çš„è§’è‰²
                characterCards.forEach(c => {
                    c.classList.remove('selected');
                });
                
                // è®¾ç½®å½“å‰é€‰ä¸­çš„è§’è‰²
                card.classList.add('selected');
                gameState.currentCharacter = card.getAttribute('data-character');
                
                // æ ¹æ®è§’è‰²è®¾ç½®åˆå§‹é“å…·
                if (gameState.currentCharacter === 'scholar') {
                    gameState.hints = 5;
                    hintCount.textContent = gameState.hints;
                }
                
                // çŒäººè§’è‰²å¢åŠ ç­”é¢˜æ—¶é—´
                if (gameState.currentCharacter === 'hunter') {
                    gameState.totalTime = 30;
                }
            });
        });

        // éš¾åº¦é€‰æ‹©æŒ‰é’®ç‚¹å‡»äº‹ä»¶
        difficultyBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                playSound(clickSound);
                
                difficultyBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                gameState.currentDifficulty = btn.getAttribute('data-difficulty');
                
                // æ›´æ–°éš¾åº¦æ˜¾ç¤ºåç§°
                const difficultyNames = {
                    'easy': 'åŸºç¡€',
                    'medium': 'æ ¸å¿ƒ',
                    'hard': 'é«˜çº§'
                };
                difficultyName.textContent = difficultyNames[gameState.currentDifficulty];
            });
        });

        // éŸ³ä¹æ§åˆ¶
        musicControl.addEventListener('click', () => {
            playSound(clickSound);
            
            if (gameState.musicPlaying) {
                backgroundMusic.pause();
                musicControl.style.background = 'rgba(255, 255, 255, 0.2)';
            } else {
                backgroundMusic.play().catch(e => {
                    console.log("è‡ªåŠ¨æ’­æ”¾è¢«é˜»æ­¢ï¼Œéœ€è¦ç”¨æˆ·äº¤äº’");
                });
                musicControl.style.background = 'rgba(255, 255, 255, 0.4)';
            }
            gameState.musicPlaying = !gameState.musicPlaying;
        });

        // éŸ³æ•ˆæ§åˆ¶
        soundControl.addEventListener('click', () => {
            playSound(clickSound);
            
            gameState.soundEnabled = !gameState.soundEnabled;
            if (gameState.soundEnabled) {
                soundControl.style.background = 'rgba(255, 255, 255, 0.4)';
            } else {
                soundControl.style.background = 'rgba(255, 255, 255, 0.2)';
            }
        });

        // å¼€å§‹æ¢é™©æŒ‰é’®ç‚¹å‡»äº‹ä»¶
        startAdventureBtn.addEventListener('click', () => {
            playSound(clickSound);
            
            if (!gameState.currentCharacter) {
                showFeedback('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ¢é™©èº«ä»½ï¼', false);
                return;
            }
            
            startAdventure();
        });

        // ä½¿ç”¨æç¤ºæŒ‰é’®ç‚¹å‡»äº‹ä»¶
        useHintBtn.addEventListener('click', () => {
            if (gameState.isProcessing) return;
            playSound(clickSound);
            
            if (gameState.hints > 0) {
                gameState.hints--;
                hintCount.textContent = gameState.hints;
                
                // æ ¹æ®å½“å‰è°œé¢˜ç±»å‹æä¾›æç¤º
                provideHint();
                
                showFeedback('ä½¿ç”¨äº†ä¸€å¼ æç¤ºåˆ¸ï¼', true);
            } else {
                showFeedback('æç¤ºåˆ¸ä¸è¶³ï¼', false);
            }
        });

        // ä¸‹ä¸€é¢˜æŒ‰é’®ç‚¹å‡»äº‹ä»¶
        nextPuzzleBtn.addEventListener('click', () => {
            if (gameState.isProcessing) return;
            playSound(clickSound);
            
            // éšæœºè§¦å‘äº‹ä»¶
            if (Math.random() < 0.4) {
                triggerRandomEvent();
            } else {
                nextQuestion();
            }
        });

        // é€€å‡ºæ¢é™©æŒ‰é’®ç‚¹å‡»äº‹ä»¶
        quitAdventureBtn.addEventListener('click', () => {
            playSound(clickSound);
            
            if (confirm('ç¡®å®šè¦é€€å‡ºæ¢é™©å—ï¼Ÿå½“å‰è¿›åº¦å°†ä¸¢å¤±ã€‚')) {
                showCharacterSelection();
            }
        });

        // å†ç©ä¸€æ¬¡æŒ‰é’®ç‚¹å‡»äº‹ä»¶
        playAgainBtn.addEventListener('click', () => {
            playSound(clickSound);
            startAdventure();
        });

        // æ›´æ¢èº«ä»½æŒ‰é’®ç‚¹å‡»äº‹ä»¶
        changeCharacterBtn.addEventListener('click', () => {
            playSound(clickSound);
            showCharacterSelection();
        });

        // äº‹ä»¶é€‰é¡¹ç‚¹å‡»äº‹ä»¶
        eventOption1.addEventListener('click', () => {
            playSound(clickSound);
            handleEventOption(1);
        });

        eventOption2.addEventListener('click', () => {
            playSound(clickSound);
            handleEventOption(2);
        });

        // å¼€å§‹æ¢é™©
        function startAdventure() {
            // é‡ç½®æ¸¸æˆçŠ¶æ€
            gameState.currentNode = 2;
            gameState.currentWordIndex = 0;
            gameState.score = 0;
            gameState.health = 5;
            gameState.isProcessing = false;
            
            // æ ¹æ®è§’è‰²è®¾ç½®åˆå§‹é“å…·
            if (gameState.currentCharacter === 'scholar') {
                gameState.hints = 5;
            } else {
                gameState.hints = 3;
            }
            gameState.revives = 1;
            gameState.detectors = 1;
            gameState.swaps = 1;
            
            // çŒäººè§’è‰²å¢åŠ ç­”é¢˜æ—¶é—´
            if (gameState.currentCharacter === 'hunter') {
                gameState.totalTime = 30;
            } else {
                gameState.totalTime = 25;
            }
            
            // æ›´æ–°UI
            healthValue.textContent = gameState.health;
            scoreValue.textContent = gameState.score;
            locationValue.textContent = gameState.locations[gameState.currentNode];
            hintCount.textContent = gameState.hints;
            reviveCount.textContent = gameState.revives;
            detectorCount.textContent = gameState.detectors;
            swapCount.textContent = gameState.swaps;
            
            // æ›´æ–°è§’è‰²åç§°æ˜¾ç¤º
            const characterNames = {
                'hunter': 'çŒäºº',
                'scholar': 'å­¦è€…',
                'craftsman': 'å·¥åŒ '
            };
            characterName.textContent = characterNames[gameState.currentCharacter];
            
            // æ›´æ–°åœ°å›¾èŠ‚ç‚¹
            updateMapNodes();
            
            // æ˜¾ç¤ºæ¸¸æˆç•Œé¢
            gameScreen.style.display = 'flex';
            characterSelection.style.display = 'none';
            resultScreen.style.display = 'none';
            
            // åŠ è½½ç¬¬ä¸€ä¸ªé—®é¢˜
            loadQuestion();
        }

        // æ›´æ–°åœ°å›¾èŠ‚ç‚¹
        function updateMapNodes() {
            document.querySelectorAll('.map-node').forEach((node, index) => {
                const nodeNum = parseInt(node.getAttribute('data-node'));
                node.classList.remove('active', 'completed');
                
                if (nodeNum < gameState.currentNode) {
                    node.classList.add('completed');
                } else if (nodeNum === gameState.currentNode) {
                    node.classList.add('active');
                }
            });
        }

        // åŠ è½½é—®é¢˜
        function loadQuestion() {
            // æ¸…é™¤ä¹‹å‰çš„è®¡æ—¶å™¨
            if (gameState.timer) {
                clearInterval(gameState.timer);
            }
            
            // é‡ç½®çŠ¶æ€
            gameState.timeLeft = gameState.totalTime;
            gameState.isProcessing = false;
            timerBar.style.width = '100%';
            nextPuzzleBtn.disabled = true;
            
            // éšæœºé€‰æ‹©è°œé¢˜ç±»å‹
            gameState.currentPuzzleType = Math.floor(Math.random() * 6);
            
            // è®¾ç½®è°œé¢˜æ ‡é¢˜
            puzzleTitle.textContent = `${gameState.puzzleTypes[gameState.currentPuzzleType]}æŒ‘æˆ˜`;
            
            // æ ¹æ®è°œé¢˜ç±»å‹åŠ è½½ä¸åŒçš„å†…å®¹
            switch(gameState.currentPuzzleType) {
                case 0: // é‡Šä¹‰é…å¯¹
                    loadMatchingPuzzle();
                    break;
                case 1: // å­—æ¯å¡«ç©º
                    loadFillBlankPuzzle();
                    break;
                case 2: // ä¾‹å¥çŒœè¯
                    loadSentencePuzzle();
                    break;
                case 3: // åŒä¹‰è¯æŒ‘æˆ˜
                    loadSynonymPuzzle();
                    break;
                case 4: // åä¹‰è¯æŒ‘æˆ˜
                    loadAntonymPuzzle();
                    break;
                case 5: // å•è¯å¡ç‰‡
                    loadWordCardPuzzle();
                    break;
            }
            
            // å¼€å§‹è®¡æ—¶
            startTimer();
        }

        // åŠ è½½é‡Šä¹‰é…å¯¹è°œé¢˜
        function loadMatchingPuzzle() {
            const scenario = gameData[gameState.currentDifficulty];
            
            // åˆ›å»ºå•è¯å’Œé‡Šä¹‰å®¹å™¨
            const wordsContainer = document.createElement('div');
            wordsContainer.className = 'matching-puzzle';
            
            const meaningsContainer = document.createElement('div');
            meaningsContainer.className = 'matching-puzzle';
            
            // éšæœºé€‰æ‹©6ä¸ªå•è¯å’Œé‡Šä¹‰
            const selectedIndices = [];
            while (selectedIndices.length < 6) {
                const randomIndex = Math.floor(Math.random() * scenario.words.length);
                if (!selectedIndices.includes(randomIndex)) {
                    selectedIndices.push(randomIndex);
                }
            }
            
            // æ‰“ä¹±é¡ºåº
            const shuffledIndices = [...selectedIndices].sort(() => Math.random() - 0.5);
            const shuffledMeanings = [...selectedIndices].sort(() => Math.random() - 0.5);
            
            // æ·»åŠ å•è¯
            shuffledIndices.forEach(index => {
                const wordItem = document.createElement('div');
                wordItem.className = 'word-item';
                wordItem.textContent = scenario.words[index];
                wordItem.dataset.index = index;
                wordsContainer.appendChild(wordItem);
            });
            
            // æ·»åŠ é‡Šä¹‰
            shuffledMeanings.forEach(index => {
                const meaningItem = document.createElement('div');
                meaningItem.className = 'meaning-item';
                meaningItem.textContent = scenario.meanings[index];
                meaningItem.dataset.index = index;
                meaningsContainer.appendChild(meaningItem);
            });
            
            // æ¸…ç©ºå®¹å™¨å¹¶æ·»åŠ æ–°å†…å®¹
            puzzleContainer.innerHTML = '';
            puzzleContainer.appendChild(wordsContainer);
            puzzleContainer.appendChild(meaningsContainer);
            
            // æ·»åŠ ç‚¹å‡»äº‹ä»¶
            document.querySelectorAll('.word-item, .meaning-item').forEach(item => {
                item.addEventListener('click', handleMatchingClick);
            });
            
            // æ·»åŠ æç¤º
            addHint("è¯·å°†è‹±æ–‡å•è¯ä¸æ­£ç¡®çš„ä¸­æ–‡é‡Šä¹‰é…å¯¹ã€‚ç‚¹å‡»ä¸€ä¸ªå•è¯ï¼Œå†ç‚¹å‡»ä¸€ä¸ªé‡Šä¹‰ï¼Œå¦‚æœé…å¯¹æ­£ç¡®ï¼Œå®ƒä»¬ä¼šå˜æˆç»¿è‰²ã€‚");
        }

        // åŠ è½½å­—æ¯å¡«ç©ºè°œé¢˜
        function loadFillBlankPuzzle() {
            const scenario = gameData[gameState.currentDifficulty];
            const currentWord = scenario.words[gameState.currentWordIndex];
            const fillBlank = scenario.fillBlanks[gameState.currentWordIndex];
            
            // åˆ›å»ºå¡«ç©ºæ˜¾ç¤º
            const fillBlankDisplay = document.createElement('div');
            fillBlankDisplay.className = 'fill-blank-puzzle';
            fillBlankDisplay.textContent = fillBlank;
            
            // åˆ›å»ºè¾“å…¥æ¡†
            const inputContainer = document.createElement('div');
            inputContainer.style.marginTop = '20px';
            inputContainer.style.textAlign = 'center';
            
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'blank-input';
            input.placeholder = 'è¾“å…¥å®Œæ•´å•è¯';
            
            const checkButton = document.createElement('button');
            checkButton.textContent = 'æ£€æŸ¥ç­”æ¡ˆ';
            checkButton.style.marginLeft = '10px';
            checkButton.addEventListener('click', () => {
                if (gameState.isProcessing) return;
                checkFillBlankAnswer(input.value, currentWord);
            });
            
            inputContainer.appendChild(input);
            inputContainer.appendChild(checkButton);
            
            // æ¸…ç©ºå®¹å™¨å¹¶æ·»åŠ æ–°å†…å®¹
            puzzleContainer.innerHTML = '';
            puzzleContainer.appendChild(fillBlankDisplay);
            puzzleContainer.appendChild(inputContainer);
            
            // æ·»åŠ æç¤º
            addHint(`æç¤ºï¼š${scenario.hints[gameState.currentWordIndex]}`);
        }

        // åŠ è½½ä¾‹å¥çŒœè¯è°œé¢˜
        function loadSentencePuzzle() {
            const scenario = gameData[gameState.currentDifficulty];
            const currentSentence = scenario.sentences[gameState.currentWordIndex];
            
            // åˆ›å»ºå¥å­æ˜¾ç¤º
            const sentenceDisplay = document.createElement('div');
            sentenceDisplay.className = 'sentence-puzzle';
            
            // å°†å¥å­ä¸­çš„ç©ºç™½éƒ¨åˆ†æ›¿æ¢ä¸ºè¾“å…¥æ¡†
            const sentenceParts = currentSentence.split('____');
            sentenceDisplay.innerHTML = `
                ${sentenceParts[0]}
                <input type="text" class="sentence-input" placeholder="è¾“å…¥å•è¯">
                ${sentenceParts[1]}
            `;
            
            // åˆ›å»ºæ£€æŸ¥æŒ‰é’®
            const checkButton = document.createElement('button');
            checkButton.textContent = 'æ£€æŸ¥ç­”æ¡ˆ';
            checkButton.style.marginTop = '20px';
            checkButton.addEventListener('click', () => {
                if (gameState.isProcessing) return;
                const input = document.querySelector('.sentence-input');
                checkSentenceAnswer(input.value, scenario.words[gameState.currentWordIndex]);
            });
            
            // æ¸…ç©ºå®¹å™¨å¹¶æ·»åŠ æ–°å†…å®¹
            puzzleContainer.innerHTML = '';
            puzzleContainer.appendChild(sentenceDisplay);
            puzzleContainer.appendChild(checkButton);
            
            // æ·»åŠ æç¤º
            addHint(`æç¤ºï¼š${scenario.hints[gameState.currentWordIndex]}`);
        }

        // åŠ è½½åŒä¹‰è¯æŒ‘æˆ˜è°œé¢˜
        function loadSynonymPuzzle() {
            const scenario = gameData[gameState.currentDifficulty];
            const currentWord = scenario.words[gameState.currentWordIndex];
            
            // åˆ›å»ºåŒä¹‰è¯æŒ‘æˆ˜æ˜¾ç¤º
            const synonymDisplay = document.createElement('div');
            synonymDisplay.className = 'synonym-puzzle';
            synonymDisplay.innerHTML = `
                <p>å•è¯: <strong>${currentWord}</strong></p>
                <p>è¯·è¾“å…¥ä¸€ä¸ªåŒä¹‰è¯:</p>
                <input type="text" class="synonym-input" placeholder="è¾“å…¥åŒä¹‰è¯">
            `;
            
            // åˆ›å»ºæ£€æŸ¥æŒ‰é’®
            const checkButton = document.createElement('button');
            checkButton.textContent = 'æ£€æŸ¥ç­”æ¡ˆ';
            checkButton.style.marginTop = '20px';
            checkButton.addEventListener('click', () => {
                if (gameState.isProcessing) return;
                const input = document.querySelector('.synonym-input');
                checkSynonymAnswer(input.value, scenario.synonyms[gameState.currentWordIndex]);
            });
            
            // æ¸…ç©ºå®¹å™¨å¹¶æ·»åŠ æ–°å†…å®¹
            puzzleContainer.innerHTML = '';
            puzzleContainer.appendChild(synonymDisplay);
            puzzleContainer.appendChild(checkButton);
            
            // æ·»åŠ æç¤º
            addHint(`æç¤ºï¼š${scenario.hints[gameState.currentWordIndex]}`);
        }

        // åŠ è½½åä¹‰è¯æŒ‘æˆ˜è°œé¢˜
        function loadAntonymPuzzle() {
            const scenario = gameData[gameState.currentDifficulty];
            const currentWord = scenario.words[gameState.currentWordIndex];
            
            // åˆ›å»ºåä¹‰è¯æŒ‘æˆ˜æ˜¾ç¤º
            const antonymDisplay = document.createElement('div');
            antonymDisplay.className = 'antonym-puzzle';
            antonymDisplay.innerHTML = `
                <p>å•è¯: <strong>${currentWord}</strong></p>
                <p>è¯·è¾“å…¥ä¸€ä¸ªåä¹‰è¯:</p>
                <input type="text" class="antonym-input" placeholder="è¾“å…¥åä¹‰è¯">
            `;
            
            // åˆ›å»ºæ£€æŸ¥æŒ‰é’®
            const checkButton = document.createElement('button');
            checkButton.textContent = 'æ£€æŸ¥ç­”æ¡ˆ';
            checkButton.style.marginTop = '20px';
            checkButton.addEventListener('click', () => {
                if (gameState.isProcessing) return;
                const input = document.querySelector('.antonym-input');
                checkAntonymAnswer(input.value, scenario.antonyms[gameState.currentWordIndex]);
            });
            
            // æ¸…ç©ºå®¹å™¨å¹¶æ·»åŠ æ–°å†…å®¹
            puzzleContainer.innerHTML = '';
            puzzleContainer.appendChild(antonymDisplay);
            puzzleContainer.appendChild(checkButton);
            
            // æ·»åŠ æç¤º
            addHint(`æç¤ºï¼š${scenario.hints[gameState.currentWordIndex]}`);
        }

        // åŠ è½½å•è¯å¡ç‰‡è°œé¢˜
        function loadWordCardPuzzle() {
            const scenario = gameData[gameState.currentDifficulty];
            const currentWord = scenario.words[gameState.currentWordIndex];
            const currentMeaning = scenario.meanings[gameState.currentWordIndex];
            const currentSentence = scenario.sentences[gameState.currentWordIndex];
            
            // åˆ›å»ºå•è¯å¡ç‰‡
            const wordCard = document.createElement('div');
            wordCard.className = 'word-card';
            wordCard.innerHTML = `
                <div class="word-card-title">å•è¯å¡ç‰‡</div>
                <div class="word-card-content">
                    <p><strong>å•è¯:</strong> ${currentWord}</p>
                    <p><strong>é‡Šä¹‰:</strong> ${currentMeaning}</p>
                    <p><strong>ä¾‹å¥:</strong> ${currentSentence}</p>
                    <p><strong>åŒä¹‰è¯:</strong> ${scenario.synonyms[gameState.currentWordIndex]}</p>
                    <p><strong>åä¹‰è¯:</strong> ${scenario.antonyms[gameState.currentWordIndex]}</p>
                </div>
            `;
            
            // åˆ›å»ºè®°å¿†æµ‹è¯•
            const memoryTest = document.createElement('div');
            memoryTest.className = 'minigame-container';
            memoryTest.innerHTML = `
                <div class="minigame-title">è®°å¿†æµ‹è¯•</div>
                <div class="minigame-content">
                    <p>è¯·å›å¿†åˆšæ‰å­¦ä¹ çš„å•è¯å¹¶å¡«å†™ï¼š</p>
                    <input type="text" class="minigame-input" placeholder="è¾“å…¥å•è¯">
                </div>
            `;
            
            // åˆ›å»ºæ£€æŸ¥æŒ‰é’®
            const checkButton = document.createElement('button');
            checkButton.textContent = 'æ£€æŸ¥ç­”æ¡ˆ';
            checkButton.style.marginTop = '20px';
            checkButton.addEventListener('click', () => {
                if (gameState.isProcessing) return;
                const input = document.querySelector('.minigame-input');
                checkWordCardAnswer(input.value, currentWord);
            });
            
            // æ¸…ç©ºå®¹å™¨å¹¶æ·»åŠ æ–°å†…å®¹
            puzzleContainer.innerHTML = '';
            puzzleContainer.appendChild(wordCard);
            puzzleContainer.appendChild(memoryTest);
            puzzleContainer.appendChild(checkButton);
            
            // æ·»åŠ æç¤º
            addHint("è¯·ä»”ç»†é˜…è¯»å•è¯å¡ç‰‡ä¸Šçš„ä¿¡æ¯ï¼Œç„¶åå®Œæˆè®°å¿†æµ‹è¯•ã€‚");
        }

        // æ·»åŠ æç¤º
        function addHint(hintText) {
            const hintContainer = document.createElement('div');
            hintContainer.className = 'hint-container';
            hintContainer.innerHTML = `
                <div class="hint-title">ğŸ’¡ æç¤º</div>
                <div class="hint-content">${hintText}</div>
            `;
            
            puzzleContainer.appendChild(hintContainer);
        }

        // å¤„ç†é…å¯¹ç‚¹å‡»
        function handleMatchingClick(event) {
            if (gameState.isProcessing) return;
            playSound(clickSound);
            
            const item = event.currentTarget;
            
            // åˆ‡æ¢é€‰ä¸­çŠ¶æ€
            if (item.classList.contains('selected')) {
                item.classList.remove('selected');
            } else {
                item.classList.add('selected');
            }
            
            // æ£€æŸ¥æ˜¯å¦æœ‰ä¸€å¯¹é€‰ä¸­çš„é¡¹ç›®
            const selectedWords = document.querySelectorAll('.word-item.selected');
            const selectedMeanings = document.querySelectorAll('.meaning-item.selected');
            
            if (selectedWords.length === 1 && selectedMeanings.length === 1) {
                gameState.isProcessing = true;
                
                const wordIndex = selectedWords[0].dataset.index;
                const meaningIndex = selectedMeanings[0].dataset.index;
                
                if (wordIndex === meaningIndex) {
                    // æ­£ç¡®é…å¯¹
                    playSound(correctSound);
                    selectedWords[0].style.background = 'rgba(76, 175, 80, 0.7)';
                    selectedMeanings[0].style.background = 'rgba(76, 175, 80, 0.7)';
                    selectedWords[0].classList.remove('selected');
                    selectedMeanings[0].classList.remove('selected');
                    
                    // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰é…å¯¹éƒ½å·²å®Œæˆ
                    const remainingWords = document.querySelectorAll('.word-item:not([style*="background"])');
                    if (remainingWords.length === 0) {
                        gameState.score += 15;
                        scoreValue.textContent = gameState.score;
                        showFeedback('å…¨éƒ¨é…å¯¹æ­£ç¡®ï¼+15åˆ†', true);
                        nextPuzzleBtn.disabled = false;
                        clearInterval(gameState.timer);
                    }
                } else {
                    // é”™è¯¯é…å¯¹
                    playSound(wrongSound);
                    selectedWords[0].style.background = 'rgba(244, 67, 54, 0.7)';
                    selectedMeanings[0].style.background = 'rgba(244, 67, 54, 0.7)';
                    setTimeout(() => {
                        selectedWords[0].style.background = '';
                        selectedMeanings[0].style.background = '';
                        selectedWords[0].classList.remove('selected');
                        selectedMeanings[0].classList.remove('selected');
                        gameState.isProcessing = false;
                    }, 1000);
                    
                    gameState.health--;
                    healthValue.textContent = gameState.health;
                    showFeedback('é…å¯¹é”™è¯¯ï¼-1ç‚¹ä½“åŠ›', false);
                    
                    // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
                    if (gameState.health <= 0) {
                        if (gameState.revives > 0) {
                            gameState.revives--;
                            reviveCount.textContent = gameState.revives;
                            gameState.health = 3;
                            healthValue.textContent = gameState.health;
                            showFeedback('ä½¿ç”¨äº†å¤æ´»å¡ï¼ä½“åŠ›æ¢å¤è‡³3ç‚¹', true);
                        } else {
                            setTimeout(() => {
                                endAdventure(false);
                            }, 1500);
                            return;
                        }
                    }
                }
                gameState.isProcessing = false;
            }
        }

        // æ£€æŸ¥å¡«ç©ºç­”æ¡ˆ
        function checkFillBlankAnswer(answer, correctAnswer) {
            gameState.isProcessing = true;
            
            if (answer.toLowerCase() === correctAnswer.toLowerCase()) {
                playSound(correctSound);
                gameState.score += 12;
                scoreValue.textContent = gameState.score;
                showFeedback('å¡«ç©ºæ­£ç¡®ï¼+12åˆ†', true);
                nextPuzzleBtn.disabled = false;
                clearInterval(gameState.timer);
            } else {
                playSound(wrongSound);
                gameState.health--;
                healthValue.textContent = gameState.health;
                showFeedback('å¡«ç©ºé”™è¯¯ï¼-1ç‚¹ä½“åŠ›', false);
                
                // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
                if (gameState.health <= 0) {
                    if (gameState.revives > 0) {
                        gameState.revives--;
                        reviveCount.textContent = gameState.revives;
                        gameState.health = 3;
                        healthValue.textContent = gameState.health;
                        showFeedback('ä½¿ç”¨äº†å¤æ´»å¡ï¼ä½“åŠ›æ¢å¤è‡³3ç‚¹', true);
                    } else {
                        setTimeout(() => {
                            endAdventure(false);
                        }, 1500);
                        return;
                    }
                }
            }
            gameState.isProcessing = false;
        }

        // æ£€æŸ¥å¥å­ç­”æ¡ˆ
        function checkSentenceAnswer(answer, correctAnswer) {
            gameState.isProcessing = true;
            
            if (answer.toLowerCase() === correctAnswer.toLowerCase()) {
                playSound(correctSound);
                gameState.score += 12;
                scoreValue.textContent = gameState.score;
                showFeedback('çŒœè¯æ­£ç¡®ï¼+12åˆ†', true);
                nextPuzzleBtn.disabled = false;
                clearInterval(gameState.timer);
            } else {
                playSound(wrongSound);
                gameState.health--;
                healthValue.textContent = gameState.health;
                showFeedback('çŒœè¯é”™è¯¯ï¼-1ç‚¹ä½“åŠ›', false);
                
                // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
                if (gameState.health <= 0) {
                    if (gameState.revives > 0) {
                        gameState.revives--;
                        reviveCount.textContent = gameState.revives;
                        gameState.health = 3;
                        healthValue.textContent = gameState.health;
                        showFeedback('ä½¿ç”¨äº†å¤æ´»å¡ï¼ä½“åŠ›æ¢å¤è‡³3ç‚¹', true);
                    } else {
                        setTimeout(() => {
                            endAdventure(false);
                        }, 1500);
                        return;
                    }
                }
            }
            gameState.isProcessing = false;
        }

        // æ£€æŸ¥åŒä¹‰è¯ç­”æ¡ˆ
        function checkSynonymAnswer(answer, correctAnswer) {
            gameState.isProcessing = true;
            
            if (answer.toLowerCase() === correctAnswer.toLowerCase()) {
                playSound(correctSound);
                gameState.score += 12;
                scoreValue.textContent = gameState.score;
                showFeedback('åŒä¹‰è¯æ­£ç¡®ï¼+12åˆ†', true);
                nextPuzzleBtn.disabled = false;
                clearInterval(gameState.timer);
            } else {
                playSound(wrongSound);
                gameState.health--;
                healthValue.textContent = gameState.health;
                showFeedback('åŒä¹‰è¯é”™è¯¯ï¼-1ç‚¹ä½“åŠ›', false);
                
                // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
                if (gameState.health <= 0) {
                    if (gameState.revives > 0) {
                        gameState.revives--;
                        reviveCount.textContent = gameState.revives;
                        gameState.health = 3;
                        healthValue.textContent = gameState.health;
                        showFeedback('ä½¿ç”¨äº†å¤æ´»å¡ï¼ä½“åŠ›æ¢å¤è‡³3ç‚¹', true);
                    } else {
                        setTimeout(() => {
                            endAdventure(false);
                        }, 1500);
                        return;
                    }
                }
            }
            gameState.isProcessing = false;
        }

        // æ£€æŸ¥åä¹‰è¯ç­”æ¡ˆ
        function checkAntonymAnswer(answer, correctAnswer) {
            gameState.isProcessing = true;
            
            if (answer.toLowerCase() === correctAnswer.toLowerCase()) {
                playSound(correctSound);
                gameState.score += 12;
                scoreValue.textContent = gameState.score;
                showFeedback('åä¹‰è¯æ­£ç¡®ï¼+12åˆ†', true);
                nextPuzzleBtn.disabled = false;
                clearInterval(gameState.timer);
            } else {
                playSound(wrongSound);
                gameState.health--;
                healthValue.textContent = gameState.health;
                showFeedback('åä¹‰è¯é”™è¯¯ï¼-1ç‚¹ä½“åŠ›', false);
                
                // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
                if (gameState.health <= 0) {
                    if (gameState.revives > 0) {
                        gameState.revives--;
                        reviveCount.textContent = gameState.revives;
                        gameState.health = 3;
                        healthValue.textContent = gameState.health;
                        showFeedback('ä½¿ç”¨äº†å¤æ´»å¡ï¼ä½“åŠ›æ¢å¤è‡³3ç‚¹', true);
                    } else {
                        setTimeout(() => {
                            endAdventure(false);
                        }, 1500);
                        return;
                    }
                }
            }
            gameState.isProcessing = false;
        }

        // æ£€æŸ¥å•è¯å¡ç‰‡ç­”æ¡ˆ
        function checkWordCardAnswer(answer, correctAnswer) {
            gameState.isProcessing = true;
            
            if (answer.toLowerCase() === correctAnswer.toLowerCase()) {
                playSound(correctSound);
                gameState.score += 15;
                scoreValue.textContent = gameState.score;
                showFeedback('è®°å¿†æµ‹è¯•æ­£ç¡®ï¼+15åˆ†', true);
                nextPuzzleBtn.disabled = false;
                clearInterval(gameState.timer);
            } else {
                playSound(wrongSound);
                gameState.health--;
                healthValue.textContent = gameState.health;
                showFeedback('è®°å¿†æµ‹è¯•é”™è¯¯ï¼-1ç‚¹ä½“åŠ›', false);
                
                // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
                if (gameState.health <= 0) {
                    if (gameState.revives > 0) {
                        gameState.revives--;
                        reviveCount.textContent = gameState.revives;
                        gameState.health = 3;
                        healthValue.textContent = gameState.health;
                        showFeedback('ä½¿ç”¨äº†å¤æ´»å¡ï¼ä½“åŠ›æ¢å¤è‡³3ç‚¹', true);
                    } else {
                        setTimeout(() => {
                            endAdventure(false);
                        }, 1500);
                        return;
                    }
                }
            }
            gameState.isProcessing = false;
        }

        // æä¾›æç¤º
        function provideHint() {
            playSound(hintSound);
            
            const scenario = gameData[gameState.currentDifficulty];
            
            switch(gameState.currentPuzzleType) {
                case 0: // é‡Šä¹‰é…å¯¹
                    // éšæœºæ˜¾ç¤ºä¸€ä¸ªæ­£ç¡®é…å¯¹
                    const wordItems = document.querySelectorAll('.word-item');
                    const meaningItems = document.querySelectorAll('.meaning-item');
                    
                    const randomIndex = Math.floor(Math.random() * wordItems.length);
                    const correctWord = wordItems[randomIndex];
                    const correctMeaning = Array.from(meaningItems).find(item => 
                        item.dataset.index === correctWord.dataset.index
                    );
                    
                    correctWord.style.background = 'rgba(255, 204, 0, 0.5)';
                    correctMeaning.style.background = 'rgba(255, 204, 0, 0.5)';
                    
                    setTimeout(() => {
                        correctWord.style.background = '';
                        correctMeaning.style.background = '';
                    }, 2000);
                    break;
                case 1: // å­—æ¯å¡«ç©º
                    const currentWord = scenario.words[gameState.currentWordIndex];
                    const input = document.querySelector('.blank-input');
                    input.value = currentWord;
                    break;
                case 2: // ä¾‹å¥çŒœè¯
                    const sentenceInput = document.querySelector('.sentence-input');
                    const correctWordForSentence = scenario.words[gameState.currentWordIndex];
                    sentenceInput.value = correctWordForSentence;
                    break;
                case 3: // åŒä¹‰è¯æŒ‘æˆ˜
                    const synonymInput = document.querySelector('.synonym-input');
                    const correctSynonym = scenario.synonyms[gameState.currentWordIndex];
                    synonymInput.value = correctSynonym;
                    break;
                case 4: // åä¹‰è¯æŒ‘æˆ˜
                    const antonymInput = document.querySelector('.antonym-input');
                    const correctAntonym = scenario.antonyms[gameState.currentWordIndex];
                    antonymInput.value = correctAntonym;
                    break;
                case 5: // å•è¯å¡ç‰‡
                    const minigameInput = document.querySelector('.minigame-input');
                    const correctWordForCard = scenario.words[gameState.currentWordIndex];
                    minigameInput.value = correctWordForCard;
                    break;
            }
        }

        // æ˜¾ç¤ºåé¦ˆ
        function showFeedback(message, isSuccess) {
            const feedback = document.createElement('div');
            feedback.textContent = message;
            feedback.style.position = 'fixed';
            feedback.style.top = '50%';
            feedback.style.left = '50%';
            feedback.style.transform = 'translate(-50%, -50%)';
            feedback.style.background = isSuccess ? 'rgba(76, 175, 80, 0.9)' : 'rgba(244, 67, 54, 0.9)';
            feedback.style.color = 'white';
            feedback.style.padding = '20px 40px';
            feedback.style.borderRadius = '10px';
            feedback.style.fontSize = '1.5rem';
            feedback.style.fontWeight = 'bold';
            feedback.style.zIndex = '1000';
            feedback.style.boxShadow = '0 5px 15px rgba(0, 0, 0, 0.3)';
            
            document.body.appendChild(feedback);
            
            setTimeout(() => {
                document.body.removeChild(feedback);
            }, 1500);
        }

        // å¼€å§‹è®¡æ—¶å™¨
        function startTimer() {
            gameState.timer = setInterval(() => {
                gameState.timeLeft--;
                const percentage = (gameState.timeLeft / gameState.totalTime) * 100;
                timerBar.style.width = `${percentage}%`;
                
                // æ—¶é—´åˆ°
                if (gameState.timeLeft <= 0) {
                    clearInterval(gameState.timer);
                    handleTimeUp();
                }
            }, 1000);
        }

        // æ—¶é—´åˆ°å¤„ç†
        function handleTimeUp() {
            playSound(wrongSound);
            
            const scenario = gameData[gameState.currentDifficulty];
            
            // æ ¹æ®ä¸åŒè°œé¢˜ç±»å‹å¤„ç†è¶…æ—¶
            switch(gameState.currentPuzzleType) {
                case 0: // é‡Šä¹‰é…å¯¹
                    // æ˜¾ç¤ºæ‰€æœ‰æ­£ç¡®é…å¯¹
                    document.querySelectorAll('.word-item').forEach(wordItem => {
                        const correctMeaning = Array.from(document.querySelectorAll('.meaning-item')).find(item => 
                            item.dataset.index === wordItem.dataset.index
                        );
                        wordItem.style.background = 'rgba(76, 175, 80, 0.7)';
                        correctMeaning.style.background = 'rgba(76, 175, 80, 0.7)';
                    });
                    break;
                case 1: // å­—æ¯å¡«ç©º
                    const currentWord = scenario.words[gameState.currentWordIndex];
                    const input = document.querySelector('.blank-input');
                    input.value = currentWord;
                    break;
                case 2: // ä¾‹å¥çŒœè¯
                    const sentenceInput = document.querySelector('.sentence-input');
                    const correctWordForSentence = scenario.words[gameState.currentWordIndex];
                    sentenceInput.value = correctWordForSentence;
                    break;
                case 3: // åŒä¹‰è¯æŒ‘æˆ˜
                    const synonymInput = document.querySelector('.synonym-input');
                    const correctSynonym = scenario.synonyms[gameState.currentWordIndex];
                    synonymInput.value = correctSynonym;
                    break;
                case 4: // åä¹‰è¯æŒ‘æˆ˜
                    const antonymInput = document.querySelector('.antonym-input');
                    const correctAntonym = scenario.antonyms[gameState.currentWordIndex];
                    antonymInput.value = correctAntonym;
                    break;
                case 5: // å•è¯å¡ç‰‡
                    const minigameInput = document.querySelector('.minigame-input');
                    const correctWordForCard = scenario.words[gameState.currentWordIndex];
                    minigameInput.value = correctWordForCard;
                    break;
            }
            
            // æ‰£å‡ä½“åŠ›
            gameState.health--;
            healthValue.textContent = gameState.health;
            
            // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
            if (gameState.health <= 0) {
                if (gameState.revives > 0) {
                    gameState.revives--;
                    reviveCount.textContent = gameState.revives;
                    gameState.health = 3;
                    healthValue.textContent = gameState.health;
                    showFeedback('æ—¶é—´åˆ°ï¼ä½¿ç”¨äº†å¤æ´»å¡ï¼ä½“åŠ›æ¢å¤è‡³3ç‚¹', false);
                } else {
                    setTimeout(() => {
                        endAdventure(false);
                    }, 1500);
                    return;
                }
            } else {
                showFeedback('æ—¶é—´åˆ°ï¼-1ç‚¹ä½“åŠ›', false);
            }
            
            // å¯ç”¨ä¸‹ä¸€é¢˜æŒ‰é’®
            nextPuzzleBtn.disabled = false;
        }

        // è§¦å‘éšæœºäº‹ä»¶
        function triggerRandomEvent() {
            const events = [
                {
                    title: "å‘ç°éšè—å®ç®±!",
                    desc: "ä½ å‘ç°äº†ä¸€ä¸ªå¤è€çš„å®ç®±ï¼Œé‡Œé¢ä¼¼ä¹æœ‰çè´µçš„é“å…·ã€‚æ˜¯å¦æ‰“å¼€ï¼Ÿ",
                    option1: "æ‰“å¼€å®ç®±",
                    option2: "è°¨æ…ç¦»å¼€",
                    result1: () => {
                        // å®ç®±å¥–åŠ±
                        const rewardType = Math.floor(Math.random() * 3);
                        if (rewardType === 0) {
                            gameState.hints += 2;
                            hintCount.textContent = gameState.hints;
                            return "è·å¾—2å¼ æç¤ºåˆ¸ï¼";
                        } else if (rewardType === 1) {
                            gameState.revives += 1;
                            reviveCount.textContent = gameState.revives;
                            return "è·å¾—1å¼ å¤æ´»å¡ï¼";
                        } else {
                            gameState.score += 20;
                            scoreValue.textContent = gameState.score;
                            return "è·å¾—20ç‚¹æ¢é™©åˆ†æ•°ï¼";
                        }
                    },
                    result2: "ä½ è°¨æ…åœ°ç¦»å¼€äº†ï¼Œæ²¡æœ‰å†’é™©æ‰“å¼€å®ç®±ã€‚"
                },
                {
                    title: "é‡åˆ°ç¥ç§˜å•†äºº",
                    desc: "ä¸€ä½ç¥ç§˜çš„å•†äººå‡ºç°åœ¨ä½ é¢å‰ï¼Œä»–æ„¿æ„ç”¨1å¼ å¤æ´»å¡äº¤æ¢2å¼ æç¤ºåˆ¸ã€‚æ˜¯å¦äº¤æ˜“ï¼Ÿ",
                    option1: "è¿›è¡Œäº¤æ˜“",
                    option2: "æ‹’ç»äº¤æ˜“",
                    result1: () => {
                        if (gameState.hints >= 2) {
                            gameState.hints -= 2;
                            gameState.revives += 1;
                            hintCount.textContent = gameState.hints;
                            reviveCount.textContent = gameState.revives;
                            return "äº¤æ˜“æˆåŠŸï¼è·å¾—1å¼ å¤æ´»å¡ã€‚";
                        } else {
                            return "æç¤ºåˆ¸ä¸è¶³ï¼Œäº¤æ˜“å¤±è´¥ã€‚";
                        }
                    },
                    result2: "ä½ æ‹’ç»äº†äº¤æ˜“ï¼Œç»§ç»­å‰è¡Œã€‚"
                },
                {
                    title: "ä½“åŠ›æ¶ˆè€—",
                    desc: "å‰æ–¹çš„é“è·¯å¼‚å¸¸å´å²–ï¼Œæ¶ˆè€—äº†å¤§é‡ä½“åŠ›ã€‚ä½ éœ€è¦å›ç­”ä¸€ä¸ªç®€å•é—®é¢˜æ¥æ¢å¤ä½“åŠ›ã€‚",
                    option1: "æ¥å—æŒ‘æˆ˜",
                    option2: "ç»•é“è€Œè¡Œ",
                    result1: () => {
                        // ç®€å•é—®é¢˜ - è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œç›´æ¥ç»™äºˆå¥–åŠ±
                        gameState.health = Math.min(gameState.health + 1, 5);
                        healthValue.textContent = gameState.health;
                        return "å›ç­”æ­£ç¡®ï¼æ¢å¤1ç‚¹ä½“åŠ›ã€‚";
                    },
                    result2: "ä½ é€‰æ‹©äº†ç»•é“ï¼Œä½†æ¶ˆè€—äº†æ›´å¤šæ—¶é—´ã€‚"
                }
            ];
            
            const randomEvent = events[Math.floor(Math.random() * events.length)];
            
            eventTitle.textContent = randomEvent.title;
            eventDesc.textContent = randomEvent.desc;
            eventOption1.textContent = randomEvent.option1;
            eventOption2.textContent = randomEvent.option2;
            
            // å­˜å‚¨å½“å‰äº‹ä»¶ç»“æœå‡½æ•°
            eventPopup.currentEvent = randomEvent;
            
            eventPopup.style.display = 'block';
        }

        // å¤„ç†äº‹ä»¶é€‰é¡¹
        function handleEventOption(option) {
            let resultMessage = "";
            
            if (option === 1) {
                if (typeof eventPopup.currentEvent.result1 === 'function') {
                    resultMessage = eventPopup.currentEvent.result1();
                } else {
                    resultMessage = eventPopup.currentEvent.result1;
                }
            } else {
                resultMessage = eventPopup.currentEvent.result2;
            }
            
            eventPopup.style.display = 'none';
            showFeedback(resultMessage, true);
            
            // ç»§ç»­ä¸‹ä¸€é¢˜
            setTimeout(() => {
                nextQuestion();
            }, 1500);
        }

        // ä¸‹ä¸€é¢˜
        function nextQuestion() {
            gameState.currentWordIndex++;
            
            if (gameState.currentWordIndex >= 10) {
                // å®Œæˆå½“å‰èŠ‚ç‚¹
                playSound(levelUpSound);
                gameState.currentNode++;
                locationValue.textContent = gameState.locations[gameState.currentNode];
                updateMapNodes();
                
                if (gameState.currentNode >= 5) {
                    // æ¢é™©å®Œæˆ
                    endAdventure(true);
                } else {
                    // é‡ç½®å•è¯ç´¢å¼•ï¼Œè¿›å…¥ä¸‹ä¸€åŒºåŸŸ
                    gameState.currentWordIndex = 0;
                    loadQuestion();
                }
            } else {
                // åŠ è½½ä¸‹ä¸€é¢˜
                loadQuestion();
            }
        }

        // ç»“æŸæ¢é™©
        function endAdventure(success) {
            // æ˜¾ç¤ºç»“æœç•Œé¢
            resultScreen.style.display = 'flex';
            gameScreen.style.display = 'none';
            
            // æ›´æ–°æœ€ç»ˆå¾—åˆ†
            finalScore.textContent = gameState.score;
            
            // æ ¹æ®ç»“æœæ˜¾ç¤ºä¸åŒæ¶ˆæ¯
            if (success) {
                resultMessage.textContent = 'æ­å–œï¼ä½ æˆåŠŸå®Œæˆäº†å•è¯ç§˜å¢ƒæ¢é™©ï¼';
            } else {
                resultMessage.textContent = 'æ¢é™©å¤±è´¥ï¼ä½ çš„ä½“åŠ›å·²è€—å°½ã€‚';
            }
        }

        // æ˜¾ç¤ºè§’è‰²é€‰æ‹©ç•Œé¢
        function showCharacterSelection() {
            characterSelection.style.display = 'flex';
            gameScreen.style.display = 'none';
            resultScreen.style.display = 'none';
        }

        // åˆå§‹åŒ–ï¼šé»˜è®¤é€‰æ‹©ç¬¬ä¸€ä¸ªè§’è‰²å’Œéš¾åº¦
        document.querySelector('.character-card').click();
        document.querySelector('.difficulty-btn').click();
    </script>
</body>
</html>